package pl.wroc.pwr.student.acteditor.view;

import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.layout.FormAttachment;
import org.eclipse.swt.layout.FormData;
import org.eclipse.swt.layout.FormLayout;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Group;
import org.eclipse.swt.widgets.Item;
import org.eclipse.swt.widgets.Listener;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Tree;
import org.eclipse.swt.widgets.TreeItem;

import pl.wroc.pwr.student.acteditor.model.Schema;
import pl.wroc.pwr.student.acteditor.parsing.Parser;
import pl.wroc.pwr.student.acteditor.parsing.xsd.Element;
import pl.wroc.pwr.student.acteditor.parsing.xsd.XSDParser;

public class DecisionWindow extends Window {
	
	public DecisionWindow(Display display) {
		this.display = display;
	}

	/**
	 * @wbp.parser.entryPoint
	 */
	@Override
	protected void initialize() {
		shell = new Shell(display);
//		Display display = new Display();
//		Shell shell = new Shell(display);
		shell.setSize(793, 657);
		shell.setText("Decision");
		shell.setMaximized(true);
		shell.setLayout(new FormLayout());
		
		Group group = new Group(shell, SWT.NONE);
		FormData fd_group = new FormData();
		fd_group.top = new FormAttachment(0, 10);
		fd_group.right = new FormAttachment(100, -255);
		group.setLayoutData(fd_group);
		
		final Parser parser = new XSDParser(Schema.getSchemaContent());
		Element decision = parser.getElement("decyzja");
		
		final Tree tree = new Tree(shell, SWT.BORDER);
		fillTree(tree, decision, parser);
//		for(Element e1 : decision.getElements()) {
//			TreeItem ti1 = new TreeItem(tree, SWT.NONE);
//			ti1.setText(e1.getName());
//			if(parser.getElement(e1.getName()).getElements() == null) {
//				continue;
//			}
//			for(Element e2 : parser.getElement(e1.getName()).getElements()) {
//				TreeItem ti2 = new TreeItem(ti1, SWT.NONE);
//				ti2.setText(e2.getName());
//				if(parser.getElement(e2.getName()).getElements() == null) {
//					continue;
//				}
//				for(Element e3 : parser.getElement(e2.getName()).getElements()) {
//					TreeItem ti3 = new TreeItem(ti2, SWT.NONE);
//					ti3.setText(e3.getName());
//				}
//			}
//		}
		
		FormData fd_tree = new FormData();
		fd_tree.bottom = new FormAttachment(0, 443);
		fd_tree.right = new FormAttachment(0, 276);
		fd_tree.top = new FormAttachment(0, 10);
		fd_tree.left = new FormAttachment(0, 10);
		tree.setLayoutData(fd_tree);
	}
	
	private void fillTree(Object tree, Element element, Parser parser, int level) {
		if(level > 10) {
			return;
		}
		level++;
		for(Element e1 : element.getElements()) {
			TreeItem ti = null;
			if(tree instanceof Tree) {
				ti = new TreeItem((Tree)tree, SWT.NONE);
			} else if(tree instanceof TreeItem) {
				ti = new TreeItem((TreeItem)tree, SWT.NONE);
			}
			ti.setText(e1.getName());
			Element e = parser.getElement(e1.getName());
			if(e.getElements() == null) {
				continue;
			}
			if(e.getName().equals(element.getName())) {
				continue;
			}
			fillTree(ti, e, parser);
		}
	}

	@Override
	protected void open() {
		shell.open();
	}

	@Override
	protected void dispose() {
	}
}
